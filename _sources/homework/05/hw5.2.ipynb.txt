{"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["## Homework 5.2: A dashboard for microarray data (70 pts)\n", "\n", "[Data set download 1](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/x.txt), [Dataset download 2](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/E-MTAB-1681.sdrf.txt), [Dataset download 3](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/430_2.0_probeset_annotation.txt)\n", "\n", "<hr>"]}, {"cell_type": "code", "execution_count": 1, "metadata": {"nbsphinx": "hidden", "tags": []}, "outputs": [], "source": ["# Colab setup ------------------\n", "import os, sys, subprocess\n", "if \"google.colab\" in sys.modules:\n", "    data_path = \"https://s3.amazonaws.com/bebi103.caltech.edu/data/\"\n", "else:\n", "    data_path = \"../data/\"\n", "# ------------------------------"]}, {"cell_type": "code", "execution_count": 2, "metadata": {}, "outputs": [], "source": ["import pandas as pd"]}, {"cell_type": "markdown", "metadata": {}, "source": ["In [our introductory lesson on Python](where_we_will_go.rst), we saw a plot of some microarray data advertising that you will soon have the skill to make such a plot. Now is your chance to not only make a single plot, but to make a dashboard to explore microarray data!\n", "\n", "As a reminder, the data come from `this paper <https://doi.org/10.1038/ncb2881>`_ by Ohnishi, et al., published in *Nature Cell Biology* in 2014. The abstract reproduced below describes their experiment.\n", "\n", ">It is now recognized that extensive expression heterogeneities among cells precede the emergence of lineages in the early mammalian embryo. To establish a map of pluripotent epiblast (EPI) versus primitive endoderm (PrE) lineage segregation within the inner cell mass (ICM) of the mouse blastocyst, we characterized the gene expression profiles of individual ICM cells. Clustering analysis of the transcriptomes of 66 cells demonstrated that initially they are non-distinguishable. Early in the segregation, lineage-specific marker expression exhibited no apparent correlation, and a hierarchical relationship was established only in the late blastocyst. Fgf4 exhibited a bimodal expression at the earliest stage analysed, and in its absence, the differentiation of PrE and EPI was halted, indicating that Fgf4 drives, and is required for, ICM lineage segregation. These data lead us to propose a model where stochastic cell-to-cell expression heterogeneity followed by signal reinforcement underlies ICM lineage segregation by antagonistically separating equivalent cells.\n", "\n", "So, they determined that [Fgf4](https://en.wikipedia.org/wiki/FGF4) expression precedes differentiation of stem cell lineages. In their study, they performed [microarray analysis](https://en.wikipedia.org/wiki/DNA_microarray) to investigate expression levels of genes in 101 different cells harvested from wild type and Fgf4\u1428\u141f\u1428 mouse blastocysts and various times in embryonic development. \n", "\n", "They deposited the microarray data to the ArrayExpress database with the accession number E-MTAB-1681, available [here](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-1681/). The processed data are available as a ZIP file [here](https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-1681/E-MTAB-1681.processed.1.zip). Upon unzipping the processed data file, you get a file, `x.txt`, which has the observed expression levels based on each of the 45,000+ probes they used.\n", "\n", "As a starting point for the dashboard, you have available the following files.\n", "\n", "- [ohnishi_2014/x.txt](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/x.txt): The intensities for each sample.\n", "- [ohnishi_2014/E-MTAB-1681.sdrf.txt](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/E-MTAB-1681.sdrf.txt): Important metadata about the samples.\n", "- [ohnishi_2014/430_2.0_probeset_annotation.txt](https://s3.amazonaws.com/bebi103.caltech.edu/data/ohnishi_2014/430_2.0_probeset_annotation.txt): Annotation of the probeset, important giving which gene each probe corresponds to.\n", "\n", "When you download these data, be sure to store them all in a `../data/ohnishi_2014/` directory.\n", "\n", "Your task is to build a dashboard to explore this data set. There 101 samples used in the microarray study, 35 of which are Fgf-4 knock-outs. Of the 66 wild type cells, 36 are pre-differentiated, 15 are PrE, and 15 are EPI cells. The cells were extracted at 3.25, 3.5, and 4.5 days in embryonic development. Over 45,000 probe sets were used, for a total of over 19,000 genes.\n", "\n", "Prior to building your dashboard, you may take the wrangling steps I now work through."]}, {"cell_type": "markdown", "metadata": {}, "source": ["We will load in data frames with the log\u2082 intensity for each probeset in each sample (`df`), characteristics for each sample (`df_char`) and the probeset annotation (`df_annotation`)."]}, {"cell_type": "code", "execution_count": 3, "metadata": {}, "outputs": [], "source": ["# Data frame with intensity values from microarray\n", "df = pd.read_csv(\n", "    os.path.join(data_path, \"ohnishi_2014/x.txt\"), delimiter=\"\\t\", header=[0, 1]\n", ")\n", "\n", "# Characteristics of each sample\n", "df_char = pd.read_csv(\n", "    os.path.join(data_path, \"ohnishi_2014/E-MTAB-1681.sdrf.txt\"), delimiter=\"\\t\"\n", ")\n", "\n", "# Annotation of probe set\n", "df_annotation = pd.read_csv(\n", "    os.path.join(data_path, \"ohnishi_2014/430_2.0_probeset_annotation.txt\"),\n", "    delimiter=\"\\t\",\n", "    skiprows=4,\n", ")\n", "\n", "# Convert to single level\n", "df.columns = df.columns.get_level_values(0)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["The main data frame contains the different samples as columns and each probeset as rows."]}, {"cell_type": "code", "execution_count": 4, "metadata": {}, "outputs": [{"data": {"text/html": ["<div>\n", "<style scoped>\n", "    .dataframe tbody tr th:only-of-type {\n", "        vertical-align: middle;\n", "    }\n", "\n", "    .dataframe tbody tr th {\n", "        vertical-align: top;\n", "    }\n", "\n", "    .dataframe thead th {\n", "        text-align: right;\n", "    }\n", "</style>\n", "<table border=\"1\" class=\"dataframe\">\n", "  <thead>\n", "    <tr style=\"text-align: right;\">\n", "      <th></th>\n", "      <th>Hybridization REF</th>\n", "      <th>H_1_C32_IN</th>\n", "      <th>H_2_C32_IN</th>\n", "      <th>H_3_C32_IN</th>\n", "      <th>H_4_C32_IN</th>\n", "      <th>H_5_C32_IN</th>\n", "      <th>H_6_C32_IN</th>\n", "      <th>H_7_C32_IN</th>\n", "      <th>H_8_C32_IN</th>\n", "      <th>H_9_C32_IN</th>\n", "      <th>...</th>\n", "      <th>H_126_e4.5_KO</th>\n", "      <th>H_127_e4.5_KO</th>\n", "      <th>H_128_e4.5_KO</th>\n", "      <th>H_129_e4.5_KO</th>\n", "      <th>H_130_e4.5_KO</th>\n", "      <th>H_131_e4.5_KO</th>\n", "      <th>H_132_e4.5_KO</th>\n", "      <th>H_133_e4.5_KO</th>\n", "      <th>H_134_e4.5_KO</th>\n", "      <th>H_135_e4.5_KO</th>\n", "    </tr>\n", "  </thead>\n", "  <tbody>\n", "    <tr>\n", "      <th>0</th>\n", "      <td>1415670_at</td>\n", "      <td>4.910459</td>\n", "      <td>7.526672</td>\n", "      <td>6.956328</td>\n", "      <td>6.424048</td>\n", "      <td>5.105808</td>\n", "      <td>5.856685</td>\n", "      <td>5.059961</td>\n", "      <td>4.574661</td>\n", "      <td>8.123073</td>\n", "      <td>...</td>\n", "      <td>8.359740</td>\n", "      <td>9.575871</td>\n", "      <td>6.179409</td>\n", "      <td>8.601108</td>\n", "      <td>8.051324</td>\n", "      <td>4.911292</td>\n", "      <td>3.801598</td>\n", "      <td>8.360182</td>\n", "      <td>7.999680</td>\n", "      <td>8.193070</td>\n", "    </tr>\n", "    <tr>\n", "      <th>1</th>\n", "      <td>1415671_at</td>\n", "      <td>9.768979</td>\n", "      <td>9.144228</td>\n", "      <td>9.295010</td>\n", "      <td>11.059831</td>\n", "      <td>9.376749</td>\n", "      <td>9.681017</td>\n", "      <td>7.665886</td>\n", "      <td>9.325743</td>\n", "      <td>9.724729</td>\n", "      <td>...</td>\n", "      <td>11.175453</td>\n", "      <td>9.591774</td>\n", "      <td>9.518947</td>\n", "      <td>10.526221</td>\n", "      <td>10.770072</td>\n", "      <td>6.375060</td>\n", "      <td>11.130234</td>\n", "      <td>8.052922</td>\n", "      <td>7.425286</td>\n", "      <td>9.148713</td>\n", "    </tr>\n", "    <tr>\n", "      <th>2</th>\n", "      <td>1415672_at</td>\n", "      <td>10.411893</td>\n", "      <td>10.918942</td>\n", "      <td>9.495738</td>\n", "      <td>10.317996</td>\n", "      <td>11.143684</td>\n", "      <td>10.234943</td>\n", "      <td>10.642970</td>\n", "      <td>9.304958</td>\n", "      <td>11.037632</td>\n", "      <td>...</td>\n", "      <td>10.885286</td>\n", "      <td>9.339838</td>\n", "      <td>9.370398</td>\n", "      <td>7.787682</td>\n", "      <td>10.084626</td>\n", "      <td>8.773603</td>\n", "      <td>10.768072</td>\n", "      <td>10.327700</td>\n", "      <td>7.729140</td>\n", "      <td>10.283193</td>\n", "    </tr>\n", "    <tr>\n", "      <th>3</th>\n", "      <td>1415673_at</td>\n", "      <td>5.618108</td>\n", "      <td>6.439416</td>\n", "      <td>6.730465</td>\n", "      <td>4.914527</td>\n", "      <td>5.619778</td>\n", "      <td>7.188673</td>\n", "      <td>6.395441</td>\n", "      <td>6.405085</td>\n", "      <td>6.542729</td>\n", "      <td>...</td>\n", "      <td>4.957310</td>\n", "      <td>5.652768</td>\n", "      <td>6.910332</td>\n", "      <td>6.694354</td>\n", "      <td>6.104253</td>\n", "      <td>5.313348</td>\n", "      <td>4.872900</td>\n", "      <td>8.932054</td>\n", "      <td>5.028091</td>\n", "      <td>4.505772</td>\n", "    </tr>\n", "    <tr>\n", "      <th>4</th>\n", "      <td>1415674_a_at</td>\n", "      <td>7.541891</td>\n", "      <td>8.380285</td>\n", "      <td>8.480580</td>\n", "      <td>7.977363</td>\n", "      <td>8.650312</td>\n", "      <td>8.639637</td>\n", "      <td>7.645431</td>\n", "      <td>5.265520</td>\n", "      <td>6.748849</td>\n", "      <td>...</td>\n", "      <td>8.592410</td>\n", "      <td>5.954694</td>\n", "      <td>8.159053</td>\n", "      <td>9.041147</td>\n", "      <td>8.667740</td>\n", "      <td>8.028946</td>\n", "      <td>5.790260</td>\n", "      <td>9.019782</td>\n", "      <td>5.045660</td>\n", "      <td>8.652528</td>\n", "    </tr>\n", "  </tbody>\n", "</table>\n", "<p>5 rows \u00d7 102 columns</p>\n", "</div>"], "text/plain": ["  Hybridization REF  H_1_C32_IN  H_2_C32_IN  H_3_C32_IN  H_4_C32_IN  \\\n", "0        1415670_at    4.910459    7.526672    6.956328    6.424048   \n", "1        1415671_at    9.768979    9.144228    9.295010   11.059831   \n", "2        1415672_at   10.411893   10.918942    9.495738   10.317996   \n", "3        1415673_at    5.618108    6.439416    6.730465    4.914527   \n", "4      1415674_a_at    7.541891    8.380285    8.480580    7.977363   \n", "\n", "   H_5_C32_IN  H_6_C32_IN  H_7_C32_IN  H_8_C32_IN  H_9_C32_IN  ...  \\\n", "0    5.105808    5.856685    5.059961    4.574661    8.123073  ...   \n", "1    9.376749    9.681017    7.665886    9.325743    9.724729  ...   \n", "2   11.143684   10.234943   10.642970    9.304958   11.037632  ...   \n", "3    5.619778    7.188673    6.395441    6.405085    6.542729  ...   \n", "4    8.650312    8.639637    7.645431    5.265520    6.748849  ...   \n", "\n", "   H_126_e4.5_KO  H_127_e4.5_KO  H_128_e4.5_KO  H_129_e4.5_KO  H_130_e4.5_KO  \\\n", "0       8.359740       9.575871       6.179409       8.601108       8.051324   \n", "1      11.175453       9.591774       9.518947      10.526221      10.770072   \n", "2      10.885286       9.339838       9.370398       7.787682      10.084626   \n", "3       4.957310       5.652768       6.910332       6.694354       6.104253   \n", "4       8.592410       5.954694       8.159053       9.041147       8.667740   \n", "\n", "   H_131_e4.5_KO  H_132_e4.5_KO  H_133_e4.5_KO  H_134_e4.5_KO  H_135_e4.5_KO  \n", "0       4.911292       3.801598       8.360182       7.999680       8.193070  \n", "1       6.375060      11.130234       8.052922       7.425286       9.148713  \n", "2       8.773603      10.768072      10.327700       7.729140      10.283193  \n", "3       5.313348       4.872900       8.932054       5.028091       4.505772  \n", "4       8.028946       5.790260       9.019782       5.045660       8.652528  \n", "\n", "[5 rows x 102 columns]"]}, "execution_count": 4, "metadata": {}, "output_type": "execute_result"}], "source": ["df.head()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["We would like to also have a column with gene names. We could do the following, where we do Boolean indexing in the annotation data frame each time to find the probeset of interest.\n", "\n", "```\n", "def probeset_to_gene(probeset):\n", "    try:\n", "        gene = df_annotation.loc[\n", "            df_annotation[\"Probeset ID\"] == probeset, \"Gene Symbol\"\n", "        ]\n", "        gene = gene.iloc[0].lower()\n", "    except:\n", "        gene = \"none\"\n", "\n", "    return gene\n", "\n", "\n", "df[\"gene\"] = df[\"Hybridization REF\"].apply(lambda x: probeset_to_gene(x))\n", "```\n", "\n", "This is very slow, since we have to do tens of thousands of reverse lookups. It is faster to first create a dictionary linking probeset names to gene names, which may be constructed in one or two passes through the annotation data frame, and then use that to populated the gene names.\n", "\n", "While we are at it, we will make another dictionary allowing us to look up probesets corresponding to each gene,just in case you may want to use it later."]}, {"cell_type": "code", "execution_count": 5, "metadata": {}, "outputs": [], "source": ["# Dictionary to look up genes by probeset\n", "genes = {\n", "    df_annotation.loc[i, \"Probeset ID\"]: df_annotation.loc[i, \"Gene Symbol\"].lower()\n", "    if type(df_annotation.loc[i, \"Gene Symbol\"]) == str\n", "    else \"none\"\n", "    for i in df_annotation.index\n", "}\n", "\n", "# Dictionary to look up probesets by gene\n", "probesets = {\n", "    gene.lower(): []\n", "    for gene in df_annotation[\"Gene Symbol\"].unique()\n", "    if type(gene) == str\n", "}\n", "probesets[\"none\"] = []\n", "for i in df_annotation.index:\n", "    if type(df_annotation.loc[i, \"Gene Symbol\"]) == str:\n", "        probesets[df_annotation.loc[i, \"Gene Symbol\"].lower()].append(\n", "            df_annotation.loc[i, \"Probeset ID\"]\n", "        )\n", "    else:\n", "        probesets[\"none\"].append(df_annotation.loc[i, \"Probeset ID\"])\n", "\n", "\n", "# Fill in the Affymetrix probesets\n", "probesets[\"AFFX\"] = []\n", "for probeset in df.loc[\n", "    df[\"Hybridization REF\"].str.contains(\"AFFX\"), \"Hybridization REF\"\n", "]:\n", "    genes[probeset] = \"AFFX\"\n", "    probesets[\"AFFX\"].append(probeset)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["With the `genes` dictionary available, we can more quickly make a column with the gene name."]}, {"cell_type": "code", "execution_count": 6, "metadata": {}, "outputs": [], "source": ["df['gene'] = df['Hybridization REF'].apply(lambda x: genes[x])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Many of the genes have multiple probes associated with them. There are many ways to treat this when analyzing microarray data to get the expression level of a given gene. We will take a simple approach and use the median intensity over all probesets for a given gene. Noe that we are overwriting the data frame in the following operation, losing information about each individual probeset. If we wanted to preserve or explore that information, we should not do this."]}, {"cell_type": "code", "execution_count": 7, "metadata": {}, "outputs": [], "source": ["df = df.groupby('gene').median().reset_index()"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Now, our task is to tidy the data frame. We want each row to be an observation, that is measures of intensity for a single mouse tissue."]}, {"cell_type": "code", "execution_count": 8, "metadata": {}, "outputs": [], "source": ["# Make tidy by transposing and renaming columns\n", "df = df.transpose(copy=True)\n", "df.columns = df.iloc[0]\n", "df = df.iloc[1:]\n", "df = df.reset_index()\n", "df = df.rename(columns={\"index\": \"Source Name\"})\n", "df[\"Source Name\"] = df[\"Source Name\"].apply(lambda x: x[2:])"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Next, we can clean up the `df_char` data frame, which was information about each sample."]}, {"cell_type": "code", "execution_count": 9, "metadata": {}, "outputs": [], "source": ["# Clean up some of the data in the characteristics data frame\n", "# Short stage name\n", "df_char[\"stage\"] = df_char[\"Characteristics[developmental stage]\"].apply(\n", "    lambda x: x.split(\" \")[-1]\n", ")\n", "\n", "# Short genotype\n", "df_char[\"genotype\"] = df_char[\"Characteristics[genotype]\"].apply(\n", "    lambda x: \"KO\" if \"KO\" in x else \"WT\"\n", ")\n", "\n", "# Short cell type\n", "df_char[\"celltype\"] = df_char[\"Source Name\"].apply(lambda x: x.split(\"_\")[-1])\n", "df_char[\"celltype\"] = df_char[\"celltype\"].apply(lambda x: \"PrE\" if x == \"PE\" else x)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["Finally, we can merge `df` and `df_char` to have a single, tidy data frame to work with."]}, {"cell_type": "code", "execution_count": 10, "metadata": {}, "outputs": [], "source": ["df = pd.merge(df, df_char)"]}, {"cell_type": "markdown", "metadata": {}, "source": ["<br />"]}], "metadata": {"kernelspec": {"display_name": "Python 3 (ipykernel)", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.8.12"}}, "nbformat": 4, "nbformat_minor": 4}