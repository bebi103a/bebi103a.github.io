{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# R7. Topics in bootstrapping\n",
    "\n",
    "*This recitation was prepared by Cecelia Andrews with help from Justin Bois. Some modifications were made by Sanjana Kulkarni.*\n",
    "\n",
    "**[Law school dataset download](https://s3.amazonaws.com/bebi103.caltech.edu/data/law_school_data.csv)**\n",
    "\n",
    "**[*C. elegans* egg cross-sectional area dataset download](https://s3.amazonaws.com/bebi103.caltech.edu/data/c_elegans_egg_xa.csv)**\n",
    "\n",
    "**[Phone repair times dataset download](https://s3.amazonaws.com/bebi103.caltech.edu/data/ilec.csv)**\n",
    "\n",
    "<hr>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Colab setup ------------------\n",
    "import os, sys, subprocess\n",
    "if \"google.colab\" in sys.modules:\n",
    "    cmd = \"pip install --upgrade iqplot bebi103 colorcet watermark\"\n",
    "    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n",
    "    stdout, stderr = process.communicate()\n",
    "    data_path = \"https://s3.amazonaws.com/bebi103.caltech.edu/data/\"\n",
    "else:\n",
    "    data_path = \"../data/\"\n",
    "# ------------------------------\n",
    "\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import numba\n",
    "import scipy.stats as st\n",
    "import bebi103\n",
    "\n",
    "import iqplot\n",
    "import timeit\n",
    "import colorcet\n",
    "\n",
    "import bokeh.io\n",
    "import bokeh.plotting\n",
    "import bokeh.layouts\n",
    "bokeh.io.output_notebook()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<hr>\n",
    "\n",
    "This this recitation, we will cover\n",
    "\n",
    "1. Review of bootstrapping concepts from Lesson 16.\n",
    "3. BCa Confidence Intervals\n",
    "4. Studentized Bootstrap\n",
    "\n",
    "\n",
    "An excellent reference, if dated, for bootstrapping calculations is Efron and Tibshirani's *An Introduction to the Bootstrap*, 1994 ([Amazon](http://www.amazon.com/Introduction-Bootstrap-Monographs-Statistics-Probability/dp/0412042312))."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Review\n",
    "\n",
    "### The plug-in principle\n",
    "\n",
    "This was covered in lesson 12.  \n",
    "\n",
    "**Simplified definition:** Say we have a sample of repeated measurements, and we know there is a generative distribution for these measurements. But, we don't know what that generative distribution is. We can estimate a parameter, $\\theta = T(F)$, of the generative distribution by computing the statistical functional using the empirical CDF rather than the actual CDF.\n",
    "\n",
    "\n",
    "**Thorough definition:**  \n",
    "Say we have a data set of repeated measurements of the lengths of *C. elegans* eggs. We know there is a generative distribution for these lengths, but we don't know any parameters of the distribution. How can we estimate a parameter of the distribution?  \n",
    "\n",
    "Call the CDF of our generative distribution $F(x)$. We want to compute a statistical functional, $T(F)$, of the CDF. $T(F)$ could be the mean, variance, median, etc. The parameter $\\theta$ is defined by the functional, so $\\theta = T(F)$.  \n",
    "\n",
    "However, we only have a sample from the generative distribution (our egg length measurements). We can compute the ECDF of our measurements, called $\\hat{F}$. The plug-in principle simply states we can estimate our parameter of interest, $\\theta$, by calculating:  \n",
    "\n",
    "\\begin{align}\n",
    "\\hat{\\theta} &= T(\\hat{F})  \n",
    "\\end{align}\n",
    "\n",
    "Essentially, the plug-in principle says we can estimate the parameter $\\theta$ by computing the statistical functional on the empirical CDF rather than the actual CDF."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Confidence Intervals\n",
    "\n",
    "These were covered in lesson 12.  \n",
    "\n",
    "\"If an experiment is repeated over and over again, the estimate I compute for a parameter, $\\hat{\\theta}$ , will lie between the bounds of the 95% confidence interval for 95% of the experiments.\" This is the frequentist interpretation. The center of the interval is treated as a fixed value (population test statistic), and the bounds are random variables that change based on the simulation.  \n",
    "\n",
    "In Bayesian statistics, the analogous interval is called a credible interval. The center is the random variable, while the bounds are treated as fixed. Therefore, the interpretation is that the population statistic has a 95% chance of lying within a 95% credible interval."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Bootstrapping\n",
    "\n",
    "Also covered in Lesson 16.  \n",
    "\n",
    "The basic idea of bootstrapping is to simulate many repetitions of the experiment. It is a type of resampling, in which you draw samples from your sample to generate a bootstrap distribution. For example, if you have a sample of 10 data points, you can samples by randomly choosing from the original set of 10 points, with replacement. \n",
    "\n",
    "Bootstrapping allows us to get a better plug-in estimate for the statistical functional as if we did the experiment many times. To see the power of bootstrapping in action, let's consider the example given in Efron and Tibshirani's *An Introduction to the Bootstrap*.  \n",
    "\n",
    "The CSV file `law_school_data.csv`, available [here](https://s3.amazonaws.com/bebi103.caltech.edu/data/law_school_data.csv), contains the population of measurements (LSAT, GPA) for N=82 American law schools for the entering classes of 1973. LSAT is the average score of the class on the LSAT (national law exam), and GPA is the average undergraduate GPA. In this example, we have a census, so we know the actual values of the summary statistics we may want to compute. Here we load in the data and view the first 10 observations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_law = pd.read_csv(os.path.join(data_path, 'law_school_data.csv'))\n",
    "df_law.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, let's pretend we are a researcher interested in estimating the mean LSAT and GPA for American law schools. It would be difficult to survey every law school in the USA and collect LSAT and GAP scores of each class, so in practice, researchers collect a sample, a subset of the population, and make inferences about the population. Say we collect a random sample of 15 law schools and want to estimate the population mean from our sample. We will simulate this by drawing a random sample of size n=15:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the random seed\n",
    "rg = np.random.default_rng(seed=3252)\n",
    "\n",
    "# Draw 15 random samples and make a new dataframe\n",
    "indices = rg.choice(np.arange(82), replace=False, size=15)\n",
    "df_sample = df_law.loc[indices]\n",
    "df_sample"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "How does this sample compare to the population? Let's compare the population mean LSAT and GPA to the sample means:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Print means\n",
    "print(f'Sample mean LSAT: {np.mean(df_sample.LSAT)}')\n",
    "print(f'Sample mean GPA: {np.mean(df_sample.GPA)}')\n",
    "print(f'Population mean LSAT: {np.mean(df_law.LSAT)}')\n",
    "print(f'Population mean GPA: {np.mean(df_law.GPA)}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The accuracy of the mean LSAT and GPA of the small sample will vary based on the sample you draw, but they can be fairly far away from the mean of the population such that the standard error does not capture the actual mean.\n",
    "\n",
    "Let's compare the ECDFs as well. To overlay the sample and population ECDFs, we will use manually compute the ECDFs of the samples and populations and overlay them on the population plots. This is easier to do since the sample and population are of different sizes. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def compute_ecdf(data):\n",
    "    \"\"\"Returns ECDF values of data\"\"\"\n",
    "    return np.arange(1, len(data) + 1) / len(data)\n",
    "\n",
    "\n",
    "# Initialize two bokeh plots using a list comprehension\n",
    "labels = [\"LSAT\", \"GPA\"]\n",
    "p_LSAT, p_GPA = [\n",
    "    bokeh.plotting.figure(\n",
    "        height=300, width=400, x_axis_label=labels[i], y_axis_label=\"ECDF\"\n",
    "    )\n",
    "    for i in range(2)\n",
    "]\n",
    "\n",
    "# Compute and plot the ECDFs for LSAT\n",
    "p_LSAT.circle(\n",
    "    np.sort(df_law.LSAT), compute_ecdf(df_law.LSAT), legend_label=\"Population\"\n",
    ")\n",
    "\n",
    "p_LSAT.circle(\n",
    "    np.sort(df_sample.LSAT),\n",
    "    compute_ecdf(df_sample.LSAT),\n",
    "    legend_label=\"Sample\",\n",
    "    color=\"darkorange\",\n",
    "    size=6,\n",
    ")\n",
    "\n",
    "# Compute and plot the ECDFs for GPA\n",
    "p_GPA.circle(\n",
    "    np.sort(df_law.GPA), compute_ecdf(df_law.GPA), legend_label=\"Population\",\n",
    ")\n",
    "\n",
    "p_GPA.circle(\n",
    "    np.sort(df_sample.GPA),\n",
    "    compute_ecdf(df_sample.GPA),\n",
    "    legend_label=\"Sample\",\n",
    "    color=\"darkorange\",\n",
    "    size=6,\n",
    ")\n",
    "\n",
    "p_LSAT.legend.location = p_GPA.legend.location = \"top_left\"\n",
    "\n",
    "bokeh.io.show(bokeh.layouts.row(p_LSAT, p_GPA))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The ECDFs match up fairly well, but if we zoom in on the 50th percentile we can see the medians may not overlap, and the means are probably off a bit, too. Let's see if we can compute a confidence interval through bootstrapping. We'll use the function `draw_bs_sample()` to draw bootstrap samples of the same size as our sample (n=15), and compute the means of each to create 1000 replicates. Remember, our bootstrap samples are always the same size as the original sample because we want to simulate repeating the same experiment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@numba.njit\n",
    "def draw_bs_sample(data):\n",
    "    \"\"\"Draw a bootstrap sample from a 1D data set.\"\"\"\n",
    "    return np.random.choice(data, size=len(data))\n",
    "\n",
    "\n",
    "# Number of bootstrap replicates we want to draw\n",
    "N = 1000\n",
    "\n",
    "sample_lsat_mean_reps = np.empty(N)\n",
    "sample_gpa_mean_reps = np.empty(N)\n",
    "\n",
    "# Turn the sample LSAT and GPA scores into arrays for use with numba\n",
    "sample_lsat = np.array(df_sample.LSAT)\n",
    "sample_gpa = np.array(df_sample.GPA)\n",
    "\n",
    "for i in range(N):\n",
    "    sample_lsat_mean_reps[i] = np.mean(draw_bs_sample(sample_lsat))\n",
    "    sample_gpa_mean_reps[i] = np.mean(draw_bs_sample(sample_gpa))\n",
    "\n",
    "print(f\"Sample mean LSAT: {np.mean(sample_lsat)}\")\n",
    "print(f\"Sample mean GPA: {np.mean(sample_gpa)}\")\n",
    "print(\"\\n\")\n",
    "print(f\"Mean LSAT 95% C.I.: {np.percentile(sample_lsat_mean_reps, [2.5, 97.5])}\")\n",
    "print(f\"Mean GPA 95% C.I.: {np.percentile(sample_gpa_mean_reps, [2.5, 97.5])}\")\n",
    "print(\"\\n\")\n",
    "print(f\"Population mean LSAT: {np.mean(df_law.LSAT)}\")\n",
    "print(f\"Population mean GPA: {np.mean(df_law.GPA)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The 95% confidence interval captures the true mean for both the LSAT and GPA data. Let's compare the ECDFs again. We will create 500 bootstrap sample ECDFs and overlay them over the population ECDF. Note: if 500 samples takes too long to render on your machine, you can change the variable `n` to something like 100. You will still see the same overall effect. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialize two bokeh plots using a list comprehension\n",
    "labels = [\"LSAT\", \"GPA\"]\n",
    "p_LSAT, p_GPA = [\n",
    "    bokeh.plotting.figure(\n",
    "        height=300, width=400, x_axis_label=labels[i], y_axis_label=\"ECDF\"\n",
    "    )\n",
    "    for i in range(2)\n",
    "]\n",
    "\n",
    "n = 500\n",
    "# Make n bootstrap samples and plot them\n",
    "for i in range(n):\n",
    "    lsat = draw_bs_sample(sample_lsat)\n",
    "    gpa = draw_bs_sample(sample_gpa)\n",
    "    # Add semitransparent ECDFs to the plot\n",
    "    p_LSAT.circle(\n",
    "        np.sort(lsat),\n",
    "        compute_ecdf(lsat),\n",
    "        color=colorcet.b_glasbey_category10[0],\n",
    "        alpha=0.05,\n",
    "    )\n",
    "    p_GPA.circle(\n",
    "        np.sort(gpa),\n",
    "        compute_ecdf(gpa),\n",
    "        color=colorcet.b_glasbey_category10[0],\n",
    "        alpha=0.05,\n",
    "    )\n",
    "\n",
    "p_LSAT.circle(\n",
    "    np.sort(df_law.LSAT),\n",
    "    compute_ecdf(df_law.LSAT),\n",
    "    color=colorcet.b_glasbey_category10[1],\n",
    "    alpha=2,\n",
    ")\n",
    "p_GPA.circle(\n",
    "    np.sort(df_law.GPA),\n",
    "    compute_ecdf(df_law.GPA),\n",
    "    color=colorcet.b_glasbey_category10[1],\n",
    "    alpha=2,\n",
    ")\n",
    "\n",
    "bokeh.io.show(bokeh.layouts.row(p_LSAT, p_GPA))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What do you notice about the bootstrapped ECDFs? Consider the approximate shape and mean.  \n",
    "\n",
    "The boostrapped samples are a pretty good approximation of the overall population distribution. \n",
    "\n",
    "Now that we've shown the power of bootstrapping, let's explore some more bootstrapping methods! First we'll review pairs bootstrapping, which we learned about in class, then go into some new methods."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Pairs Bootstrap\n",
    "\n",
    "Also covered in Lesson 16. See the lesson for a coding example.  \n",
    "\n",
    "We use pairs bootstrapping when we have paired data, and we will often want to compute the correlation. The important thing to remember with pairs bootstrapping is that we draw a random sample of *pairs*, not 2 random samples of each array. For example, if we have paired data in 2 arrays: $\\mathbf{x} = [x_1, x_2,\\ldots, x_n]$ and $\\mathbf{y} = [y_1, y_2,\\ldots, y_n]$, we must draw the same indices from both arrays so we end up with paired samples:  \n",
    "\n",
    "\\begin{align}\n",
    "&\\mathbf{\\hat{x}} = [x_i, x_j, x_k,\\ldots, x_n], \\text{ and}\\\\[1em]  \n",
    "&\\mathbf{\\hat{y}} = [y_i, y_j, y_k,\\ldots, y_n].\n",
    "\\end{align}\n",
    "\n",
    "**Question**: Why do we have to keep pairs together to estimate correlation? What result will you likely get for the correlation if your pairs get separated?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. BCa Confidence Intervals\n",
    "\n",
    "The BCa confidence interval is the bias-corrected accelerated bootstrap confidence interval. This concept was introduced by Bradley Efron. The BCa interval is designed to automatically create confidence intervals that adjust for underlying higher order effects. In simple terms, it corrects for bias and skew in the distribution of bootstrap estimates.  \n",
    "\n",
    "In this recitation, we will focus on the nonparametric case and show a coding example. If you want to dive into this concept even more, which I highly recommend, take a look at [Efron, \"Better Bootstrap Confidence Intervals.\" Journal of the American Statistical Association 82, no. 397 (1987): 171-85](https://doi.org/10.2307/2289144). \n",
    "\n",
    "Let's consider the *C. elegans* egg data example again. We have a dataset of repeated measurements of the areas *C. elegans* eggs. We know there is a generative distribution for this data, but we don't know what it is. We want to compute a confidence interval of the mean. For the general case, we'll call the statistic we want to estimate $\\theta$. As we know, the standard confidence interval is given by: \n",
    "\n",
    "\\begin{align}\n",
    "\\theta \\in [\\hat{\\theta} + \\hat{\\sigma}z^{(\\alpha)}, \\hat{\\theta} + \\hat{\\sigma}z^{(1 - \\alpha)}] \\tag{2.1}\n",
    "\\end{align}\n",
    "\n",
    "\n",
    "where $\\hat{\\theta}$ is our sample estimate of $\\theta$, $\\hat{\\sigma}$ is our estimate of the standard deviation of the distribution of $\\hat{\\theta}$, and $z^{(\\alpha)}$ is the $100 \\times \\alpha$ percentile point of a standard normal variate.\n",
    "\n",
    "This standard confidence interval (Equation 2.1) is based on taking the asymptotic normal approximation  \n",
    "\n",
    "\\begin{align}\n",
    "(\\hat{\\theta} - \\theta)/\\hat{\\sigma} \\sim N(0, 1) \\tag{2.2}\n",
    "\\end{align}\n",
    "\n",
    "In our case, and in many cases, we assume there is a generative distribution, $g$, for our data. Thus, we can achieve normality and constant standard error by considering the monotone transformation $\\hat{\\phi} = g(\\hat{\\theta})$ and $\\phi = g(\\theta)$ instead of $\\hat{\\theta}$ and $\\theta$. We assume this transformation is both **normalizing** and **variance stabilizing** (defined momentarily). Through this method, we can now compute the confidence interval for $\\phi$ based on:  \n",
    "\n",
    "\\begin{align}\n",
    "(\\hat{\\phi} - \\phi)/\\tau \\sim N(-z_0, 1) \\tag{2.3}\n",
    "\\end{align}\n",
    "\n",
    "where $\\tau$ is the constant standard error of $\\hat{\\phi}$ and $z_0$ is the bias constant. To get the confidence interval for $\\theta$, we take the inverse transformation $\\theta = g^{-1}(\\phi)$. The great part: all of this is achieved automatically simply through bootstrapping! We do not need to know $g$ or $z_0$.\n",
    "\n",
    "How can we improve on this? That's where BCa comes in. Like we described previously, through bootstrapping alone we are assuming the transformation $g$ is both normalizing and variance stabilizing. A [variance stabilizing transformation](https://en.wikipedia.org/wiki/Variance-stabilizing_transformation) is a transformation such that the variance is no longer related to the mean. For some distributions (ex. Binomial), the variance is dependent on the mean. A variance stabilizing transformation removes this dependence. But, since we do not know the transformation, we do not know for sure that it is variance stabilizing. In the BCa confidence interval, we only need to know that $g$ is normalizing. This makes it more accurate in many cases!\n",
    "\n",
    "The BCa incorporates some bias constant, $z_0$, and some acceleration constant, $a$, such that the BCa confidence interval is based on: \n",
    "\n",
    "\\begin{align}\n",
    "&(\\hat{\\phi} - \\phi)/\\tau \\sim N(-z_0\\sigma_\\phi, \\sigma_\\phi^2),\\\\[1em]\n",
    "&\\sigma_\\phi = 1 + a\\phi. \\tag{2.4}\n",
    "\\end{align}\n",
    "\n",
    "We can determine $a$ and $z_0$ by resampling our data. Here, we are considering the nonparametric case. For the nonparametric case, the acceleration constant for the mean is given by\n",
    "\n",
    "\\begin{align}\n",
    "a = \\frac{\\sum_i (x_i - \\bar{x})^3}{6\\left(\\sum_i (x_i - \\bar{x})^2\\right)^{3/2}}.\n",
    "\\tag{2.5}\n",
    "\\end{align}\n",
    "\n",
    "We can compute $z_0$ from our bootstrap replicates. The bias-correction constant, $z_0$, is: \n",
    "\n",
    "\\begin{align}\n",
    "z_0 = \\phi^{-1}(\\hat{G}(\\hat{\\theta}))\n",
    "\\tag{2.6}\n",
    "\\end{align}\n",
    "\n",
    "From the plug-in principle, we know that for the nonparametric case we can approximate the CDF $\\hat{G}(\\hat{\\theta})$ as the ECDF of our bootstrap replicates. So, $\\phi^{-1}(\\hat{G}(\\hat{\\theta}))$ is given by the inverse ECDF of our bootstrap replicates. \n",
    "\n",
    "This may all be a little confusing now, so let's practice with the worm egg example! I will review how to compute each parameter as we go.\n",
    "\n",
    "Let's load in our worm egg area dataset, digitized from [Harvey and Orbidans's 2011 PLoS One paper](https://doi.org/10.1371/journal.pone.0025840)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_worms = pd.read_csv(os.path.join(data_path, 'c_elegans_egg_xa.csv'), comment='#')\n",
    "df_worms.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And we show an ECDF to get a feel for the data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "p = iqplot.ecdf(data=df_worms, q=\"area (sq. um)\", cats=\"food\")\n",
    "\n",
    "bokeh.io.show(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It looks like worms that received more food have smaller eggs. Any hypotheses for why that may be the case?\n",
    "\n",
    "We'll convert the data we're interested into arrays, separated by how much food the worms received:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fed_worms = df_worms.loc[df_worms['food'] == 'high']['area (sq. um)'].values\n",
    "hungry_worms = df_worms.loc[df_worms['food'] == 'low']['area (sq. um)'].values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we write some helper functions to calculate the parameters for the BCa interval. We will combine them in our main function, `compute_bca_ci()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define \"statfunction\" as the function we want to apply to the replicates.\n",
    "\n",
    "\n",
    "def compute_jackknife_reps(data, statfunction=np.mean):\n",
    "    \"\"\"Returns jackknife resampled replicates for \n",
    "    the given data and statistical function\"\"\"\n",
    "    # Set up empty array to store jackknife replicates\n",
    "    jack_reps = np.empty(len(data))\n",
    "\n",
    "    # For each observation in the dataset, compute the statistical function on the sample\n",
    "    # with that observation removed\n",
    "    for i in range(len(data)):\n",
    "        jack_sample = np.delete(data, i)\n",
    "        jack_reps[i] = statfunction(jack_sample)\n",
    "    return jack_reps\n",
    "\n",
    "\n",
    "def compute_a(jack_reps):\n",
    "    \"\"\"Returns the acceleration constant a\"\"\"\n",
    "    mean = np.mean(jack_reps)\n",
    "    return (1 / 6) * np.divide(\n",
    "        np.sum(mean - jack_reps) ** 3, (np.sum(mean - jack_reps) ** 2) ** (3 / 2)\n",
    "    )\n",
    "\n",
    "\n",
    "def bootstrap_replicates(data, n_reps=1000, statfunction=np.mean):\n",
    "    \"\"\"Computes n_reps number of bootstrap replicates for \n",
    "    given data and statistical function\"\"\"\n",
    "    boot_reps = np.empty(n_reps)\n",
    "    for i in range(n_reps):\n",
    "        boot_reps[i] = statfunction(draw_bs_sample(data))\n",
    "    return boot_reps\n",
    "\n",
    "\n",
    "def compute_z0(data, boot_reps, statfunction=np.mean):\n",
    "    \"\"\"Computes z0 for given data and statistical function\"\"\"\n",
    "    s = statfunction(data)\n",
    "    return st.norm.ppf(np.sum(boot_reps < s) / len(boot_reps))\n",
    "\n",
    "\n",
    "def compute_bca_ci(data, alpha_level, n_reps=1000, statfunction=np.mean):\n",
    "    \"\"\"Returns BCa confidence interval for given data at given alpha level\"\"\"\n",
    "    # Compute bootstrap and jackknife replicates\n",
    "    boot_reps = bootstrap_replicates(data, n_reps, statfunction)\n",
    "    jack_reps = compute_jackknife_reps(data, statfunction)\n",
    "\n",
    "    # Compute a and z0\n",
    "    a = compute_a(jack_reps)\n",
    "    z0 = compute_z0(data, boot_reps, statfunction)\n",
    "\n",
    "    # Compute confidence interval indices\n",
    "    alphas = np.array([alpha_level / 2.0, 1 - alpha_level / 2.0])\n",
    "    zs = z0 + st.norm.ppf(alphas).reshape(alphas.shape + (1,) * z0.ndim)\n",
    "    avals = st.norm.cdf(z0 + zs / (1 - a * zs))\n",
    "    ints = np.round((len(boot_reps) - 1) * avals)\n",
    "    ints = np.nan_to_num(ints).astype(\"int\")\n",
    "\n",
    "    # Compute confidence interval\n",
    "    boot_reps = np.sort(boot_reps)\n",
    "    ci_low = boot_reps[ints[0]]\n",
    "    ci_high = boot_reps[ints[1]]\n",
    "    return (ci_low, ci_high)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now compute the BCa confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f\"Fed worms mean egg area 95% C.I.: {compute_bca_ci(fed_worms, 0.05)}\")\n",
    "print(f\"Hungry worms mean egg area 95% C.I.: {compute_bca_ci(hungry_worms, 0.05)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Studentized Bootstrap\n",
    "\n",
    "The Studentized bootstrap error aims to reduce coverage error of our resampling. It is a good idea to use Studentized bootstrapping to approximate your statistic of interest when you suspect the distribution of your sample may not be close to the actual population distribution. The Studentized bootstrapping method works because even when this is the case, the distribution of the sample statistic divided by estimated standard error could be close to the actual population statistic divided by the population standard error. This the same principle employed in the Student-t test. \n",
    "\n",
    "The Studentized bootstrap involves taking inner and outer bootstrap samples. The algorithm is as follows:\n",
    "\n",
    "1. Compute $\\hat{\\theta}$, the sample test statistic\n",
    "2. A large number of times (number of reps ≈1000), draw a bootstrap sample. Call this the outer sample:\n",
    "    a. Compute the statistical functional on the sample\n",
    "    b. Resample your bootstrap sample ≈50 to 100 times. Call this the inner sample:\n",
    "        i. Compute the statistical function on the resample\n",
    "    c. For your inner sample replicates, compute the standard deviation\n",
    "3. Compute your statistic of interest from your replicates: t = (outer sample replicates) / (standard deviation of the inner sample replicates)\n",
    "4. Compute `s` = standard deviation of your outer sample replicates\n",
    "3. Multiply `t` by `s`\n",
    "5. Compute the confidence interval from the $\\alpha/2$ and $(1 - \\alpha)/2$ percentiles of t*s\n",
    "\n",
    "\n",
    "Let's try this out on a dataset of the repair times of landline phones in New York City. The New York Public Utilities Commission monitors the response time for repairing landline phones in the state, and repair times are dependent on the time of year, type of repair, and geographical location. The data here are for one class of repairs at one time period for a specific Incumbent Local Exchange Carrier, which is a telephone company which once held the regional monopoly on landline service. \n",
    "\n",
    "This times come from a particular time and region of New York City, so we expect them to not be representative of the population of all phone repair times ever recorded in New York City. First, we read in the data (which I obtained from the online textbook for UC Berkeley's Data 100 class found [here](https://www.textbook.ds100.org/))."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_times = pd.read_csv(os.path.join(data_path, \"ilec.csv\"))\n",
    "\n",
    "p = iqplot.ecdf(data=df_times, q=\"17.5\", x_axis_label=\"Phone Repair Times\")\n",
    "\n",
    "bokeh.io.show(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We see that the distribution is heavily positively skewed, making this a good dataset from which to draw studentized boostrap replicates. For computing the confidence intervals of the means, we'll want to convert the data of interest into arrays, and take a look at the sample mean:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "times = np.array(df_times[\"17.5\"])\n",
    "print(f\"Mean average repair time: {np.mean(times)} hours\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, we'll employ the Studentized bootstrap to compute the confidence interval of the average landline repair time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def studentized_bootstrap_ci(\n",
    "    data,\n",
    "    statfunction=np.mean,\n",
    "    n_bs_samples=1000,\n",
    "    n_inner_samples=100,\n",
    "    ptiles=(2.5, 97.5),\n",
    "):\n",
    "\n",
    "    thetas = np.empty(n_bs_samples)\n",
    "    ts = np.empty(n_bs_samples)\n",
    "\n",
    "    # Outer sample (regular bootstrap sample)\n",
    "    for i in range(n_bs_samples):\n",
    "        sample = draw_bs_sample(data)\n",
    "        theta = statfunction(sample)\n",
    "        thetas[i] = theta\n",
    "\n",
    "        # Inner sample\n",
    "        resample_stats = np.empty(n_inner_samples)\n",
    "        for j in range(n_inner_samples):\n",
    "            resample = draw_bs_sample(sample)\n",
    "            resample_stats[j] = statfunction(resample)\n",
    "\n",
    "        # Compute statistic of interest\n",
    "        ts[i] = np.sum(resample_stats - theta) / np.std(resample_stats)\n",
    "\n",
    "    ts = np.sort(ts)\n",
    "    s = np.std(thetas)\n",
    "\n",
    "    p1, p2 = np.percentile(s * ts, ptiles)\n",
    "    ci_high = np.mean(data) - (s * p1)\n",
    "    ci_low = np.mean(data) - (s * p2)\n",
    "\n",
    "    # Return the confidence interval\n",
    "    return (ci_low, ci_high)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To time small processes, I use the `timeit` module, which has a method called `default_timer()` that initializes a timer in seconds when called. The time is constantly counting up, and you can store the time at any given instant in a variable. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get the start time before the computation\n",
    "start = timeit.default_timer()\n",
    "studentized_ci = studentized_bootstrap_ci(times)\n",
    "\n",
    "# Get the end time after\n",
    "end = timeit.default_timer()\n",
    "\n",
    "print(f\"Average Repair Time 95% C.I.: {studentized_ci}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We check how long the computation took for 1000 outer bootstrap samples and 100 inner samples. We will also compare this to the time required to get 1000 bootstrap replicates using the percentile method. The studentized method is longer both because of the inner samples and the computations themselves. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f\"Studentized confidence interval took {end-start} seconds to run.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For comparison, we can compute the non-Studentized confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@numba.njit\n",
    "def draw_bs_reps_mean(data, size=1):\n",
    "    \"\"\"Draw boostrap replicates of the mean from 1D data set.\"\"\"\n",
    "    out = np.empty(size)\n",
    "    for i in range(size):\n",
    "        out[i] = np.mean(draw_bs_sample(data))\n",
    "    return out\n",
    "\n",
    "# Get the start time before the computation\n",
    "start = timeit.default_timer()\n",
    "times_bs = draw_bs_reps_mean(times, size=N)\n",
    "times_ci = np.percentile(times_bs, [2.5, 97.5])\n",
    "\n",
    "# Get the end time after\n",
    "end = timeit.default_timer()\n",
    "\n",
    "print(f\"Average Repair Time 95% C.I.: {times_ci}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(f\"Percentile confidence interval took {end-start} seconds to run.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The non-Studentized confidence interval is smaller, and we can more easily see the difference in the following plot. We also note that the studentized computation takes longer than the percentile bootstrap even with just 1000 bootstrap samples. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "percentile_dict = {\n",
    "    \"estimate\": np.mean(times),\n",
    "    \"conf_int\": times_ci,\n",
    "    \"label\": \"percentile\",\n",
    "}\n",
    "studentized_dict = {\n",
    "    \"estimate\": np.mean(times),\n",
    "    \"conf_int\": studentized_ci,\n",
    "    \"label\": \"studentized\",\n",
    "}\n",
    "\n",
    "kwargs = {\n",
    "    \"title\": \"95% Confidence Intervals\",\n",
    "    \"x_axis_label\": \"Average Phone Repair Time (hours)\",\n",
    "}\n",
    "\n",
    "p = bebi103.viz.confints(\n",
    "    [percentile_dict, studentized_dict],\n",
    "    palette=colorcet.b_glasbey_category10[0],\n",
    "    **kwargs\n",
    ")\n",
    "bokeh.io.show(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Studentized confidence intervals are most useful for very small datasets (so less likely to be representative of the population) or datasets that are highly skewed. The extra (inner) sampling attempts to correct for the lack of information with a more rigorous treatment. \n",
    "\n",
    "The main drawback is that it takes much longer than the percentile bootstrapping method. For datasets that are not skewed or very small, the two methods should give approximately equal confidence intervals. If you like, you can repeat this analysis on the bees and pesticides data in lesson 16. This sample distribution is closer to the population distribution, so the two methods give similar confidence intervals. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Computing environment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%load_ext watermark\n",
    "%watermark -v -p numpy,scipy,numba,bokeh,iqplot,bebi103,colorcet,jupyterlab"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
